# 参考記事

- https://zenn.dev/ak/articles/eeff318b5cecb4?redirected=1

# JavaScript の歴史

- 1990 年代前半、JavaScript が誕生する前の Web ページは、主にテキストや画像が表示されるだけの、いわゆる静的なページがほとんどだった
- ただし、当時 Web ページに「動き」を付ける手段がまったく無かったわけではなかった
  - 1993 年に登場した「CGI」と呼ばれる技術を使えば、チャットや掲示板、アクセスカウンターなどのような Web コンテンツを（サーバーサイドの力を借りて）動的に生成することができた
  - 「Java アプレット」と呼ばれる技術を使えば、Java で作ったプログラムを Web ページの中に埋め込むこともできた
- しかし、これらの技術はいずれも処理が重くなりがちだった上に、使える人が高度な技術を持ったプログラマーたちに限られていたため、あまり一般的に普及することはなかった
- そんな中、1995 年に Netscape Communications 社でプログラマーとして働いていた Brendan Eich（ブレンダン・アイク） 氏によって JavaScript が開発された
- そして自社の Netscape Navigator に埋め込んだ
- それを面白く思わなかった Microsoft が Internet Explorer に JScript という言語を組み込んだ（Netscape Communications が JavaScript のライセンス供与を認めなかったため）
- 次第に JavaScript と JScript の互換性の無さが目立つようになった
- そこで、この問題を解決するために登場したのが「Ecma International」(情報や通信技術の分野の規格を策定する国際的な標準化団体)
  - 当時乱立していた JavaScript の実装を一つにまとめるために動き出し
- Ecma International は、「JavaScript」と「JScript」の共通する部分を抜き出し、それをベースに標準的な仕様を策定した
  - こうして作り出された新しい仕様は「ECMAScript」と呼ばれ、各ブラウザベンダーはこの ECMAScript に沿って JavaScript を実装することが基本方針となった

# Babel

- ECMAScript 2015+ コードを、古いブラウザまたは環境で実行できる下位互換バージョンの JavaScript に変換するために使用される JavaScript コンパイラー
- Babel の登場背景
  - ECMAScript の新しいバージョンは毎年リリースされる
  - 新しい機能が ECMAScript に追加されると、（一部の）エンジニアはそれらの機能をすぐにでも利用したいと考える
  - しかし、新しい ECMAScript の仕様がリリースされたからといって、その内容がすぐにブラウザに反映されるとは限らない
  - 全てのブラウザに完全に実装されるまでには時間がかかる場合がある
  - そこで、この課題を解決するために登場したのが「Babel」
  - Babel は、ざっくり簡単に言うと、新しい ECMAScript 構文を古い ECMAScript の構文に変換するツール
  - Babel を利用することで、私たちエンジニアは古いブラウザに対応しつつも、ブラウザに実装されていない JavaScript の新しい構文を自由に使うことができる

# モジュールとは

- Web アプリケーションを開発する際は、プログラムを機能ごとなどの適切な単位に分割するのが一般的です。この分割された 1 つ 1 つのプログラムの塊のことを「モジュール」と呼びます
- JavaScript は、大きなプログラムを書くというよりも、どちらかというと Web サイトにちょっとした動きや効果を与えるために開発された
- そのため、他のプログラミング言語が当たり前のように持っている「モジュールシステム（コードから別のファイルを読み込む仕組み）」も JavaScript には用意されていなかった
- しかし、時代が進むにつれて、JavaScript を使った Web の開発がメインになってくると、当然、モジュールシステムの欠如で困る場面が増えてきました。そこで、困った当時のプログラマーたちは、以下のように HTML ファイルの中に複数の script タグを埋め込むことで、他の JavaScript ファイルの読み込みを実現していた
- ただし、この方法には 依存関係を自分で解決しなければならないという問題があった
- そこで、この問題を解決するために 2009 年に登場したのが「CommonJS」というプロジェクト
  - この仕様に沿って実装されたのが、「Node.js」と呼ばれるサーバーサイド JavaScript の実行環境
- CommonJS の大部分はモジュールに関する仕様だったので、Node.js を利用すれば、他の言語と同じように JavaScript でモジュールの読み込み / 公開ができるようになった
- Node.js では完璧に上手くいくのですが、この仕組みを使ってブラウザでも同じように動かそうとすると、「require is not defined」というエラーがコンソールに表示されてしまう
- 当時は Node.js で作られた便利な npm のパッケージが世の中にたくさん公開されていたので、それらをブラウザ上でも利用したいと考える人が大勢いました。そこで誕生したのが「Browserify」というモジュールバンドラー
- 「Browserify」とは、2011 年に substack 氏によって作られたモジュールバンドラー
  - 「モジュールバンドラー」とは、名前の通り、モジュールをひとまとめにするツールのこと
- 前述のとおり、CommonJS の登場によって、サーバーサイドの JavaScript ではモジュールを快適に扱うことができるようになりました。問題は、ブラウザ上では CommonJS 形式のモジュールがサポートされていないので、実行時に「require is not defined」というエラーが出てしまうこと
- それならば、ブラウザ上で require を使わなくても済むように、あらかじめ複数の JavaScript ファイルを結合（バンドル）し、ブラウザが解釈可能な 1 枚の JavaScript ファイルを作っておこう、という発想が生まれました。これが「モジュールバンドラー」というツールの考え方
- そうすることで、たとえ CommonJS 形式で記述されたプログラムであっても、ブラウザ上で自由に実行できるようになります。
- さて、モジュールバンドラーが登場したことによって、Node.js だけではなくブラウザ上でも CommonJS 形式のモジュールが利用できるようになりました。これでようやく、ブラウザの世界にも "モジュールシステム" がもたらされた
- しかし、CommonJS というのは元々 Kevin Dangoor 氏らが中心となって作り出した独自の JavaScript の仕様です。なので当然、当時のプログラマーたちの間では『標準的なモジュールシステムを使いたい』というニーズがあった
- そこで登場したのが「ECMAScript Modules」です。ECMAScript Modules は、2015 年の ES2015（ES6）のときに策定されたモジュールシステムで、略して「ES Modules」や「ESM」などと呼ばれる
- この ESM の登場によって、ブラウザではモジュールの読み込み / 公開の記法が、より直感的に書けるようになりました。皆さんお馴染みの import / export 構文

# SPA とは

- 従来の Web アプリケーション（Multi Page Application）では、ユーザーが何らかの操作を行ってクライアント側からリクエストが送信されると、サーバー側はそのたびにその操作に応じて適切な Web ページの情報（HTML / CSS / JavaScript など）を送信していた
- そして、クライアント側はサーバー側から Web ページの情報を受け取ると、それをもとに Web ページの内容を毎回まるごと書き換えていた
- このため、ユーザーは通信のたびに Web ページが完全に切り替わるのを待ってから、次の操作を行わなければなかった
- そこで、この問題を解決するために登場したのが「SPA（Single Page Application）」
- SPA は、名前のとおり単一の Web ページで構成される Web アプリケーションのことで、「CSR（Client Side Rendering）」と呼ばれるクライアント側でのレンダリング技術を使って、Web ページのコンテンツの一部を動的に書き換える
  - JSON 形式で API サーバーからレスポンスが返される
- しかし、CSR には問題点もあります。それは、初回のページの表示速度が遅いという点
- CSR では初回リクエスト時に、まず HTML ファイルをダウンロードするのですが、 この HTML の中身はほとんど "空っぽ" のようなものなので、初期表示では何も表示されない
- そのため、この問題を避けるべく「SSR（Server Side Rendering）」と呼ばれるレンダリング技術が登場した
- SSR では、初回アクセス時のみサーバー側で JavaScript の実行と HTML 生成を行い、それ以降のアクセスでは、クライアント側でページの差分更新を行う
- Web ページが表示されるまでの単純な待ち時間は CSR よりもかなり短くなります。そのため、SSR では CSR よりもユーザーのストレスをより軽減することができる
