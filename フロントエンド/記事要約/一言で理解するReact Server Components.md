# 参考

- https://zenn.dev/uhyo/articles/react-server-components-multi-stage
- https://eh-career.com/engineerhub/entry/2023/07/14/093000

# 一言で React Server Components を理解する

- 一言で言うと、React Server Components は多段階計算
- RSC の最も基本的なメンタルモデルは、「React アプリケーションの中に、サーバーで実行される部分とクライアント側で実行される部分がある」ということ
- 順序的にはサーバー → クライアントの順序で実行されます。これはまさに「プログラムの評価を多段階に分けて処理」していると言って問題ないでしょう。これは、多段階計算の中でも 2 段階のもの
- ちなみに、2 段階の計算の場合は「stage 0 のプログラム」と「stage 1 のプログラム」があります。stage 0 のプログラムを実行すると stage 1 のプログラムが出力されて、stage 1 のプログラムを実行すると最終結果が得られます。RSC の場合、「サーバー側」が stage 0、「クライアント側」が stage 1 に相当します。

# React Server Components は PHP か？

- RSC の話題では、よく「PHP の再来」「歴史は繰り返す」と言われることがあります
- 実は的を射た指摘です
- なぜなら、PHP もまた、「サーバー側で実行 → クライアント側で実行」というアーキテクチャになっているという意味では、多段階計算に近いものだからです
- PHP プログラムを実行すると、HTML（+JavaScript）が出力されます。これがクライアントに送信され、HTML および JavaScript がクライアント側で実行（解釈）されることによって Web ページが完成するのです
- PHP プログラムは、HTML+JavaScript を生成するという意味で、「プログラムを生成するプログラム」であると言えます。stage 0 が PHP の構文で、stage 1 が HTML+JavaScript で書かれます
- RSC は PHP から歴史が一周してきたものですから、当時に比べて進化しています。RSC が PHP と異なる点は、2 つの段階が両方とも React で書かれていることです。つまり、PHP が「HTML+JavaScript」を出力するプログラムであったならば、RSC（のサーバー側）は「クライアント側用の React アプリケーション」を出力するプログラムと言えます

# React Server Components の理解と受容の仕方

- RSC においては「コンポーネントがサーバー用とクライアント用に分類される」という新しい概念が登場し、しかもサーバー用のコンポーネントは useState が使えないなど制限があるため、ここを難しいと感じる人もいるようです。
- しかし、筆者はどちらかというと、「新しいステージが追加された」という理解をしています。従来の React アプリケーションは、stage 1 だけが存在しました。クライアント用の React アプリケーションひとつだけが存在したのです。
- SSR という技術もありましたが、これはクライアント向けのコードを無理やりサーバーサイドでも実行するものです。
- 一方、RSC では従来の React アプリケーション（stage 1）の前段に、新ステージとして stage 0 が追加されたのです。stage 0 では、stage 1 に比べて、ステートが無いなどの制限があります。よって、最も自然な RSC の受容の仕方は、「とりあえず全部 stage 1（クライアント用）にしておけば従来通り。そこに stage 0（Server Component）を足していく」というものになるでしょう。
- しかし、現在 RSC を利用する簡単な方法である Next.js（の app ディレクトリ）では、デフォルトが stage 0 で、stage 1 のファイルには"use client"という宣言を書かないといけないことになっています。つまり、従来とはデフォルトのステージが変わっているのです。ここにメンタルモデルの飛躍があり、一部の人々にとっては混乱の原因になっているのではないかと思います。
  - つまり、stage 1 のファイルには"use client"という宣言を書かないといけないという点で、stage 0 がデフォルトになってしまっている
  - これは、「とりあえず全部 stage 1（クライアント用）にしておけば従来通り。そこに stage 0（Server Component）を足していく」という思想に反する
- このようにデフォルトが変わっている理由の推測としては、RSC をいったん理解すれば、なるべく stage 0 に寄せたほうが有利だと気付くから
- 一般には stage 0 に寄せたほうが転送量的に有利
- コンポーネントの処理が減るので実行時のパフォーマンス的にも有利
- stage 0（サーバー用）のコンポーネントは制限が多くありますが、その制限を解除するにはコンポーネントを stage 1（クライアント用）に移す必要があります。これは、ステートの使用などを解禁する代わりに、パフォーマンスの悪化にオプトインする行為だと見なせます。今どきの Web フロントエンドアプリケーションを作る人はバンドルサイズの増加に自覚的になるべきですから、筆者的にはこのようなモデルは望ましいと思います
- どうせ RSC を理解してもらう必要があるなら、ついでにメンタルモデルの転換も済ませてもらったほうが理想的だということで、デフォルトが stage 0 になったのではないかと推測します。

# stage 0 と stage 1 の分け方

- なぜ人々はフロントエンドで JavaScript を使うのでしょうか？　それは、UX のためです
- ユーザーの操作に対して最速でフィードバックを返すためにはサーバーと通信するのは遅すぎるため、クライアントサイドの JavaScript などでフィードバックの処理を行う必要があります
- このようなアプリケーションをうまく書けるようにするのが React の役目です
- 一方で、その目的のためにアプリケーション全部を（従来の）React で書くのはオーバーヘッドが大きすぎるということに人々が気づき始めたようです。React をただのテンプレートエンジンのように使っているコンポーネントも多く見られます。テンプレートエンジンというのは、基本的にはサーバーサイドで使われてきたものです。つまり、本来 UX のためにはクライアントサイドの JavaScript が必要だが、UX に関係ない部分はサーバーサイドで処理したほうが良いにもかかわらず、従来の React では全部クライアントサイドで処理してしまっていたのです
- RSC では、「テンプレートエンジンとして使われている React コンポーネント」を stage 0 としてサーバー側に移すことができます。一方、ユーザーの操作に反応する部分は従来通り stage 1 とする必要があります。
- つまり、コンポーネントを stage 0 にするか stage 1 にするか迷った場合は、そのコンポーネントの役割を考えれば大抵は解決するでしょう。
- さらに、テンプレートエンジンとして考えれば、RSC がなぜ今のような形態になっているのか理解できます。皆さんはサーバーサイド用のテンプレートエンジンを使うとき、生で使うよりも何かのフレームワークに乗って使うことが多いのではないでしょうか。それは RSC（のサーバー側）であっても例外ではなく、Next.js などのフレームワークに乗って使うのを基本的なユースケースとしてデザインされています。

# Next.js での例

- 最後に Next.js での挙動についてもう少し踏み込んで説明します
- というのも、RSC を多段階計算として見ると、すでに説明したとおり「サーバー側で stage 0 を実行 → クライアント側で stage 1 を実行」という流れになります
- では、「サーバー側で stage 0 を実行」というのは具体的にどのように行われるのでしょうか
- 実は、stage 0 の実行にはいくつかのパターンがあります
- れは、従来の用語で言う SSR・SG (Static Generation)・ISR などの分類に似ています。対応するページがリクエストの情報に依存しないもの（いわゆる SG 可能なもの）であれば、stage 0 の実行はビルド時に行なってしまえばよいですね。stage 0 の実行がリクエスト時の情報に依存するものであれば、実際にページにアクセスするたびにサーバー側で stage 0 の実行が行われることになります
- ややこしいので注意してほしい点は、RSC の導入後は、「SSR」とは「サーバーサイドでも stage 1 の実行を行い、生成された HTML をレスポンスに埋め込んで返すこと」を指すことになります。RSC より前の時代は SSR は「アプリケーション全体（stage 1 のみ）をサーバーサイドでも実行すること」でしたから、RSC を「サーバー側に stage 0 が追加されるもの」と考えれば理解できます

# メモ

- 従来のいわゆる SSR では、必ず「サーバー側で React アプリをレンダリング → クライアント側でも同じアプリをレンダリングして hydration」というステップを踏む必要があったため、アプリケーションの全体をクライアントに送る必要がありました。RSC ではこの原則を廃し、コンポーネントを「サーバー用」と「クライアント用」に分類して後者のみをクライアントに送るのがポイント
- RSC の仕組みを簡単に説明すると、React アプリケーションをサーバー側で処理される部分とクライアント側で処理される部分に分け、なるべく多くをサーバー側で処理してしまうことで、クライアント側（ユーザーのブラウザ）に送るデータ転送量や、クライアント側の処理量を減らすというものです。これによって、パフォーマンスの改善が見込めます。
- 従来から、いわゆるサーバーサイドレンダリング（SSR）により Core Web Vitals で言うところの LCP（Largest Contentful Paint）の改善がなされてきました。一方、RSC の恩恵としては、INP（Interaction to Next Paint）など、どちらかと言えば応答性の向上が期待できます。そのため、実際には SSR と RSC を組み合わせて利用することになるでしょう。
- ちなみに、RSC ではサーバー用とクライアント用の 2 種類にコンポーネントを分類する必要がありますが、それぞれで利用できる機能が異なります。サーバー用のコンポーネントでは、従来の React では使用できなかった async 関数コンポーネントが可能です。一方、useState や useEffect といった動的な挙動を含むフックはサーバー用コンポーネントからは使用できず、クライアント用のコンポーネントでのみ利用できます。
- そもそも、我々が Web アプリケーションを作る際に JavaScript を使用する理由は、ユーザーの行動に対して即座に反応し、素早いフィードバックを与えるためです。フィードバックを返すためにサーバーと 1 往復の通信を行うのは時間がかかりすぎます。ブラウザ上で動く JavaScript を用いてアプリケーションを構築する理由はここにあります。逆に言えば、ユーザーの行動に反応するのがクライアント側コンポーネントの責務である一方、アプリケーションのそれ以外の部分はサーバー側で処理してもよいということです。
- つまり、サーバー側のコンポーネントとクライアント側のコンポーネントの区別は案外明確です。JavaScript の役割に照らして、本当にユーザーのブラウザ上で動く必要がある挙動を持つコンポーネントはクライアント側で、そうでないものはサーバー側にすればよいですね。例えば useState はステートを宣言するフックですが、ステートというのは、ステートの値が変わったときにコンポーネントを再レンダリングするための機能です。これは要するにサーバーとの通信を介さずに画面を変化させる機能ですから、クライアント側だからこそ意味があると言えます。
- 従来の React では素早い反応のために全てをクライアント側で実行していましたが、このように、よくよく考えてみるとあらゆるコードをクライアント側で実行する必要はありません。その揺り戻しの結果として RSC が作られたと解釈できます。サーバー側とクライアント側の連携というのは難しいものですが、そこをうまくやってくれるのが RSC です。

# Next.js ─ React 向けフレームワークのデファクトスタンダード

- 今から Next.js を使うのであれば、最近安定化された機能である App Router を使用するのがおすすめです。RSC の例でも取り上げましたが、App Router とは、app というディレクトリ内でファイルシステムベースのルーティングを行うことができる機能です。従来の Pages Router（pages ディレクトリ以下でルーティングを行うもの）に比べても、App Router は新機能である分、いろいろな利点があります。
- 特に筆者が大きな利点だと感じているのは、コロケーションの利便性の向上です。従来 Pages Router においては pages 以下に配置されたファイルは例外なくルート（URL を持ったページ）として扱われるため、そうではないファイルは pages の外に配置する必要がありました。App Router では app 内のファイルの役割が多様化しており、ルートとして扱われるファイルとそうでないファイルを app 内に混在させることができます（ただし、その裏返しとして、特別なファイル名が何個もあったり、(..)や\_, [ ], @など多様な記号がファイル名・ディレクトリ名として登場するなどルールが複雑化していることは否めません）。
- おすすめとは言え、App Router を採用すると自動的に RSC が付いてくるので、この記事で解説したようなサーバー側とクライアント側の区別なども理解する必要が出てきます。総評としては、使いこなせるようになるまでのハードルがやや高いものの、使い方を身につければ理想形に近い状態で React を使えるのが Next.js の魅力です。
