# 参考

- https://zenn.dev/uhyo/articles/react-server-components-multi-stage

# 一言で React Server Components を理解する

- 一言で言うと、React Server Components は多段階計算
- RSC の最も基本的なメンタルモデルは、「React アプリケーションの中に、サーバーで実行される部分とクライアント側で実行される部分がある」ということ
- 順序的にはサーバー → クライアントの順序で実行されます。これはまさに「プログラムの評価を多段階に分けて処理」していると言って問題ないでしょう。これは、多段階計算の中でも 2 段階のもの
- ちなみに、2 段階の計算の場合は「stage 0 のプログラム」と「stage 1 のプログラム」があります。stage 0 のプログラムを実行すると stage 1 のプログラムが出力されて、stage 1 のプログラムを実行すると最終結果が得られます。RSC の場合、「サーバー側」が stage 0、「クライアント側」が stage 1 に相当します。

# React Server Components は PHP か？

- RSC の話題では、よく「PHP の再来」「歴史は繰り返す」と言われることがあります
- 実は的を射た指摘です
- なぜなら、PHP もまた、「サーバー側で実行 → クライアント側で実行」というアーキテクチャになっているという意味では、多段階計算に近いものだからです
- PHP プログラムを実行すると、HTML（+JavaScript）が出力されます。これがクライアントに送信され、HTML および JavaScript がクライアント側で実行（解釈）されることによって Web ページが完成するのです
- PHP プログラムは、HTML+JavaScript を生成するという意味で、「プログラムを生成するプログラム」であると言えます。stage 0 が PHP の構文で、stage 1 が HTML+JavaScript で書かれます
- RSC は PHP から歴史が一周してきたものですから、当時に比べて進化しています。RSC が PHP と異なる点は、2 つの段階が両方とも React で書かれていることです。つまり、PHP が「HTML+JavaScript」を出力するプログラムであったならば、RSC（のサーバー側）は「クライアント側用の React アプリケーション」を出力するプログラムと言えます

# React Server Components の理解と受容の仕方

- RSC においては「コンポーネントがサーバー用とクライアント用に分類される」という新しい概念が登場し、しかもサーバー用のコンポーネントは useState が使えないなど制限があるため、ここを難しいと感じる人もいるようです。
- しかし、筆者はどちらかというと、「新しいステージが追加された」という理解をしています。従来の React アプリケーションは、stage 1 だけが存在しました。クライアント用の React アプリケーションひとつだけが存在したのです。
- SSR という技術もありましたが、これはクライアント向けのコードを無理やりサーバーサイドでも実行するものです。
- 一方、RSC では従来の React アプリケーション（stage 1）の前段に、新ステージとして stage 0 が追加されたのです。stage 0 では、stage 1 に比べて、ステートが無いなどの制限があります。よって、最も自然な RSC の受容の仕方は、「とりあえず全部 stage 1（クライアント用）にしておけば従来通り。そこに stage 0（Server Component）を足していく」というものになるでしょう。
- しかし、現在 RSC を利用する簡単な方法である Next.js（の app ディレクトリ）では、デフォルトが stage 0 で、stage 1 のファイルには"use client"という宣言を書かないといけないことになっています。つまり、従来とはデフォルトのステージが変わっているのです。ここにメンタルモデルの飛躍があり、一部の人々にとっては混乱の原因になっているのではないかと思います。
  - つまり、stage 1 のファイルには"use client"という宣言を書かないといけないという点で、stage 0 がデフォルトになってしまっている
  - これは、「とりあえず全部 stage 1（クライアント用）にしておけば従来通り。そこに stage 0（Server Component）を足していく」という思想に反する
- このようにデフォルトが変わっている理由の推測としては、RSC をいったん理解すれば、なるべく stage 0 に寄せたほうが有利だと気付くから
- 一般には stage 0 に寄せたほうが転送量的に有利
- コンポーネントの処理が減るので実行時のパフォーマンス的にも有利
- stage 0（サーバー用）のコンポーネントは制限が多くありますが、その制限を解除するにはコンポーネントを stage 1（クライアント用）に移す必要があります。これは、ステートの使用などを解禁する代わりに、パフォーマンスの悪化にオプトインする行為だと見なせます。今どきの Web フロントエンドアプリケーションを作る人はバンドルサイズの増加に自覚的になるべきですから、筆者的にはこのようなモデルは望ましいと思います
- どうせ RSC を理解してもらう必要があるなら、ついでにメンタルモデルの転換も済ませてもらったほうが理想的だということで、デフォルトが stage 0 になったのではないかと推測します。

# stage 0 と stage 1 の分け方

- なぜ人々はフロントエンドで JavaScript を使うのでしょうか？　それは、UX のためです
- ユーザーの操作に対して最速でフィードバックを返すためにはサーバーと通信するのは遅すぎるため、クライアントサイドの JavaScript などでフィードバックの処理を行う必要があります
- このようなアプリケーションをうまく書けるようにするのが React の役目です
- 一方で、その目的のためにアプリケーション全部を（従来の）React で書くのはオーバーヘッドが大きすぎるということに人々が気づき始めたようです。React をただのテンプレートエンジンのように使っているコンポーネントも多く見られます。テンプレートエンジンというのは、基本的にはサーバーサイドで使われてきたものです。つまり、本来 UX のためにはクライアントサイドの JavaScript が必要だが、UX に関係ない部分はサーバーサイドで処理したほうが良いにもかかわらず、従来の React では全部クライアントサイドで処理してしまっていたのです
- RSC では、「テンプレートエンジンとして使われている React コンポーネント」を stage 0 としてサーバー側に移すことができます。一方、ユーザーの操作に反応する部分は従来通り stage 1 とする必要があります。
- つまり、コンポーネントを stage 0 にするか stage 1 にするか迷った場合は、そのコンポーネントの役割を考えれば大抵は解決するでしょう。
- さらに、テンプレートエンジンとして考えれば、RSC がなぜ今のような形態になっているのか理解できます。皆さんはサーバーサイド用のテンプレートエンジンを使うとき、生で使うよりも何かのフレームワークに乗って使うことが多いのではないでしょうか。それは RSC（のサーバー側）であっても例外ではなく、Next.js などのフレームワークに乗って使うのを基本的なユースケースとしてデザインされています。

# Next.js での例

- 最後に Next.js での挙動についてもう少し踏み込んで説明します
- というのも、RSC を多段階計算として見ると、すでに説明したとおり「サーバー側で stage 0 を実行 → クライアント側で stage 1 を実行」という流れになります
- では、「サーバー側で stage 0 を実行」というのは具体的にどのように行われるのでしょうか
- 実は、stage 0 の実行にはいくつかのパターンがあります
- れは、従来の用語で言う SSR・SG (Static Generation)・ISR などの分類に似ています。対応するページがリクエストの情報に依存しないもの（いわゆる SG 可能なもの）であれば、stage 0 の実行はビルド時に行なってしまえばよいですね。stage 0 の実行がリクエスト時の情報に依存するものであれば、実際にページにアクセスするたびにサーバー側で stage 0 の実行が行われることになります
- ややこしいので注意してほしい点は、RSC の導入後は、「SSR」とは「サーバーサイドでも stage 1 の実行を行い、生成された HTML をレスポンスに埋め込んで返すこと」を指すことになります。RSC より前の時代は SSR は「アプリケーション全体（stage 1 のみ）をサーバーサイドでも実行すること」でしたから、RSC を「サーバー側に stage 0 が追加されるもの」と考えれば理解できます
